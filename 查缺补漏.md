# 查缺补漏

## printf -- sprintf -- fprintf

- 变参函数：参数形参中有"..."，最后一个固参通常是格式描述串(包含格式匹配符)，函数的参数个数，类型，顺序由这个固参决定。

1. printf("%d=%d%c%d\n",10+5,10,'+',5);           -->屏幕

2. char buf[1024];

   sprintf(buf,"%d=%d%c%d\n",10+5,10,'+',5);  -->buf中

3. FILE *fp=fopen("..");

   fprintf(fp,"%d=%d%c%d\n",10+5,10,'+',5);     -->fp对应的文件中

## memset函数

- memset函数是C语言中的一个库函数，用于将一块内存区域的每个字节都设置为指定的值。它的函数原型如下：

```c
void *memset(void *s, int c, size_t n);
```

- 其中，`s`是指向要被设置的内存区域的指针，`c`是要设置的值，`n`是要设置的字节数。

- 该函数会将指针`s`指向的内存区域的每个字节都设置为`c`指定的值，一共设置`n`个字节。返回的是指向`void`类型的指针，指向设置后的内存区域的起始位置。

- 使用`memset`函数可以快速地将一块内存区域清零或者设置为指定的值。

## bzero函数

- bzero函数是一个C语言标准库函数，用于将一块内存区域的每个字节都设置为0。它的函数原型如下：

```c
void bzero(void *s, size_t n);
```

- 其中，`s`是指向要被设置的内存区域的指针，`n`是要设置的字节数。
- 该函数会将指针`s`指向的内存区域的每个字节都设置为0，一共设置`n`个字节。
- bzero函数与memset函数的功能类似，但是**bzero函数只能将内存区域设置为0，而memset函数可以设置为任意指定的值**。
- 需要注意的是，bzero函数在C99标准中已经被标记为废弃，推荐使用memset函数代替。

## offsetof函数

- offsetof是一个C语言宏，用于计算结构体中成员的偏移量。它的定义如下：

```c
#include <stddef.h>

#define offsetof(type, member) ((size_t) &((type *)0)->member)
```

- 其中，type是结构体的类型，member是结构体中的成员。

- 使用offsetof的步骤如下：

1. 包含头文件`<stddef.h>`。
2. 使用offsetof宏，传入结构体的类型和成员的名称。

- 我们可以使用offsetof来计算结构体中成员的偏移量：

```c
#include <stdio.h>
#include <stddef.h>

struct Person {
    char name[20];
    int age;
    float height;
};

int main() {
    size_t offset = offsetof(struct Person, age);
    printf("The offset of age in struct Person is: %zu\n", offset);
    
    return 0;
}

输出结果为：
    The offset of age in struct Person is: 20
```

## scanf获取带有空格的字符串

- 注意： 1) 用于存储字符串的空间必须足够大，防止溢出。

  ​			2) 获取字符串，%s，遇到空格 和 \n 终止

- 借助"正则表达式"，获取带有空格的字符串：scanf("%[ ^\n ]",str);    ^：表示除...之外

## 字符串操作函数

```c
gets：获取一个字符串，返回字符串的首地址。可以获取带有空格的字符串。【不安全】
    char *gets(char *s);
		参数：用来存储字符串的空间地址。
        返回值：返回实际获取到的字符串首地址。              
```

```c
fgets：获取一个字符串，预留 \0 的存储空间。空间足够读 \n，空间不足舍弃 \n 【安全】
    char *fgets(char *s,int size,FILE *stream);
		参1：用来存储字符串的空间地址。
        参2：描述空间的大小。
        参3：读取字符串的位置。标准输入：stdin
        返回值：返回实际获取到的字符串首地址。    
```

```c
puts：将一个字符串写出到屏幕。puts("hello")；输出字符串会自动添加 \n 换行符。
    int puts(const char *s);
		参1：待写到屏幕的字符串。
        返回值：成功：非负数。失败：-1.    
```

```c
fputs：将一个字符串写到stdout。输出字符串后，不添加 \n 换行符。
    int fputs(const char *str,FILE *stream);
		参1：待写到屏幕的字符串。		标准输出：stdout
        参2：写出位置 stdout
        返回值：成功：0.失败：-1    
```

```c
strlen：碰到 \0 结束。
    size_t strlen(const char *s);
		参1：待求长度的字符串。
        返回：有效的字符个数。    
```

## 指针

### 指针和内存单元

- 指针：地址
- 内存单元：计算机中内存最小的存储单位。大小为一个字节。每个存储单元都有一个唯一的编号。称这个内存单元的编号为"地址"
- 指针变量：存地址的变量

![Snipaste_2023-09-23_10-25-10](F:\图片管理中心\学习\Snipaste_2023-09-23_10-25-10.png)

### 指针的定义和使用

- *p：将p变量的内容取出，当成地址看待，找到该地址对应的内存空间。
  - 如果做左值：存数据到空间中
  - 如果做右值：取出空间中的内容
- 任意"指针"类型的大小：**指针的大小与类型无关。只与当前使用的平台架构有关**。32位：4字节。64位：8字节

### 野指针和空指针

- 野指针

```c
1) 没有一个有效的地址空间的指针
    int *p;
	*p=1000;
2)p变量有一个值，但该值不是可访问的内存区域
    int *p=10;	(0~255留给操作系统)
	*p=2000;
【杜绝野指针】
```

- 空指针

```c
	int *p=NULL;
	*p时p所对应的存储空间一定是一个 无效的访问区域
```

### 万能指针/泛型指针(void *)

```c
可以接收任意一种变量地址。但是，在使用必须借助"强转"具体化数据类型
    char ch='R';
	void *p;	//万能指针，泛型指针
	p=&ch;
	printf("%c\n",*(char *)p);
```

### const关键字

- 修饰变量

```c
const int a=20;
int *p=&a;
*p=650;
printf("%d\n",a);	//650
```

- 修饰指针

```c
1) const int *p;
	可以修改p，不可以修改*p
2) int const *p;
	同上
3) int *const p;
	可以修改*p，不可以修改p
4) const int *const p;
	不可以修改p，不可以修改*p
总结：const 向右修饰，被修饰的部分即为只读。
常用：在函数形参内，用来限制指针所对应的内存空间为只读。        
```

### 指针和数组

- 数组名

```c
【数组名是地址常量】 --- 不可以被赋值
 指针是变量。可以用数组名给指针赋值   
```

- 取数组元素

```c
int arr[]={1,3,5,7,9};
int *p=arr;
arr[0]= *(arr+0) = p[0] =*(p+0)
```

- 指针和数组区别

```c
1) 指针是变量。数组名为常量。
2) sizeof(指针) ==》	4/8
    sizeof(数组) ==》 数组的实际字节数
```

- 指针++操作数组

```c
int arr[]={1,2,3,4,5,6,7,8,9,0};
int *p=arr;
for(size_t i=0;i<n;i++){
    printf("%d",*p);
    p++;	//p=p+1;	一次加过一个int大小。一个元素
}
p的值会随着循环不断变化。打印结束后，p指向一块无效地址空间(野指针)
```



![Snipaste_2023-09-23_15-06-38](F:\图片管理中心\学习\Snipaste_2023-09-23_15-06-38.png)

### 指针加减运算

- 数据类型对指针的作用

```c
1) 间接引用：决定了从指针存储的地址开始，向后读取的字节数。(与指针本身存储空间无关)
2) 加减运算：决定了指针进行+1操作后加过的 字节数    
```

- 指针 *  / % ：error！！
- 指针 +- 整数

```c
1) 普通指针变量+-整数
    char  *p；打印p，p+1 偏过 1 字节。
    short *p；打印p，p+1 偏过 2 字节。
    int   *p；打印p，p+1 偏过 4 字节。
2) 在数组中 +- 整数
    int arr[]={1,3,5,8};
	short *p=arr;
	p+4;		//向右(后)偏移2个元素
	p-2;		//向前(左)偏移1个元素
3) &数组名+1
    加过一个 数组的大小(数组元素个数 * sizeof(数组元素类型))
    int a[]={1,2,3,4,5,6,7,8,9,0};
	printf("&a=%p\n",&a);
	printf("&a+1=%p\n",&a+1);
```

- 指针 +- 指针

```
1) 指针 + 指针：error！！
2) 指针 - 指针：
    1. 普通变量来说，语法允许。无实际意义。
    2. 数组来说：偏移过的元素个数。
```

- 指针实现strlen函数

```c
char str[]="hello";
char *p=str;
while(*p!='\0'){
    p++;
}
return p-str;	即为有效元素的个数
```

- 指针比较运算

```c
1) 普通变量来说，语法允许。无实际意义。
2) 数组来说：地址之间可以进行比较大小
   可以得到，元素存储的先后顺序
3)  int *p;
	p=NULL;
	if(p!=NULL)				//这两行等价于：int *p=NULL;
        printf("p is not NULL");
	else 
        printf("p is NULL");
```

### 指针数组

- 一个存储地址的数组。数组内部所有元素都是地址。
- 指针数组本质，是一个二级指针。
- 二维数组，也是一个二级指针。

### 指针和函数

#### 栈帧

- 当函数调用时，系统会在stack空间上申请一块内存区域，用来供函数调用，主要存放 形参 和 局部变量。
- 当函数调用结束，这块内存区域自动被释放。【系统标记这块空间，没有被立即释放】

#### 数组做函数参数

- void BubbleSort(int arr[10]) == **void BubbleSort(int arr[]) == void BubbleSort(int *arr)**
- **传递不再是整个数组，而是数组的首地址。(一个指针的大小)。**
- 所以，当整型数组做函数参数时，我们通常在函数定义中，封装两个参数。一个表数组首地址，一个表元素个数。

#### 指针做函数返回值

```c
int *test_func(int a,int b);
指针做函数返回值，不能返回【局部变量的地址值】。
```

#### 数组做函数返回值

- C语言，不允许！！！只能写成指针形式。

### 指针和字符串

```c
1) 
    char str1[]={'h','i','\0'};			//变量，可读可写
	char str2[]="hi";					//变量，可读可写
	char *str3="hi";					//常量，只读
	char *str4={'hi','i','\0'};			//错误！！！
2)
    当字符串(字符数组)，做函数参数时，不需要提供2个参数。因为每个字符串都有'\0'。
```

```c
数组定义字符串和指针定义字符串的主要差别在于内存的分配方式和字符串的可修改性。

1. 内存分配方式：
- 数组定义字符串：在定义数组时，需要指定数组的大小，并且在编译时就会分配对应大小的内存空间。
- 指针定义字符串：指针定义字符串时，可以直接指向一个字符串常量或者动态分配的内存空间。

2. 字符串的可修改性：
- 数组定义字符串：数组定义的字符串是可修改的，可以通过修改数组中的元素来改变字符串的内容。
- 指针定义字符串：指针定义的字符串通常是不可修改的，如果指针指向的是一个字符串常量，那么该字符串是只读的，无法通过指针修改其内容。如果指针指向的是动态分配的内存空间，那么可以通过指针修改字符串的内容。

总结来说，数组定义字符串在编译时需要确定大小，可以修改字符串内容；指针定义字符串可以动态分配内存，但通常是不可修改的。
```

### 函数指针

- **函数名本质就是一个函数指针**
- 可以利用函数指针调用函数

#### 函数指针的定义

```c++
	//1，先定义出函数类型，再通过类型定义函数指针
	typedef void(FUNC_TYPE)(int, char);
	FUNC_TYPE* pFunc = func;
	pFunc(1, 'a');

	//2，定义出函数指针类型，通过类型定义函数指针变量
	typedef void(*FUNC_TYPE2)(int, char);
	FUNC_TYPE2 pFunc2 = func;
	pFunc2(2, 'b');

	//3，直接定义函数指针变量
	void(*pFunc3)(int, char) = func;
	pFunc3(3, 'c');
```

#### 函数指针 和 指针函数 区别

```c++
	//函数指针 和 指针函数 区别？
	//函数指针 指向了函数的指针
	//指针函数 函数返回值是指针的函数
```

#### 函数指针数组

```c++
//函数指针的数组
void func1() {
	cout << "func1被调用" << endl;
}
void func2() {
	cout << "func2被调用" << endl;
}
void func3() {
	cout << "func3被调用" << endl;
}

void test02() {
	void(*pArray[3])();
	pArray[0] = func1;
	pArray[1] = func2;
	pArray[2] = func3;

	for (int i = 0; i < 3; i++) {
		pArray[i]();
	}
}
```

## 字符串处理函数

### 字符串拷贝

- strcpy

```c
char *strcpy(char *dest,const char *src)
    将src的内容，拷贝给dest。返回dest。保证dest空间足够大。【不安全】
    函数调用结束 返回值和 dest参数结果一致
```

- strncpy

```c
char *strncpy(char *dest,const char *src,size_t n)
    将src的内容，拷贝给dest。返回dest。只拷贝n个字节。通常n与dest对应的空间一致
    默认 不添加 '\0'
    特性：n>src：只拷贝 src的大小
    	 n<src：只拷贝n字节大小。不添加'\0'
```

### 字符串拼接

- strcat

```c
char *strcat(char *dest,const char *src)
    将src的内容，拼接到dest后。返回拼接后的字符串。要保证dest空间足够大。
```

- strncat

```c
char *strncat(char *dest,const char *src,size_t n)
    将src的前n个字符串。拼接到dest后。形成一个新的字符串。要保证dest空间足够大。
```

### 字符串比较

- strcmp

```c
int strcmp(const char *s1,const char *s2)
    比较s1和s2两个字符串，如果相等，返回0。如果不相等，进一步比较s1和s2对应ASCII码值。
    s1>s2返回1
    s1<s2返回-1
```

- strncmp

```c
int strcmp(const char *s1,const char *s2,size_t n)
    比较s1和s2两个字符串前n个字符，如果相等，返回0。如果不相等，进一步比较s1和s2对应ASCII码值。
    s1>s2返回1
    s1<s2返回-1
```

- strncasecmp

```c
int strcmp(const char *s1,const char *s2,size_t n)	//忽略大小写
```

### 字符串格式化输入、输出

- sprintf

```c
int sprintf(char *str,const char *format,...)
    对应printf，将原来写到屏幕的"格式化字符串"，写到参数1 str中
    char str[100]
    sprintf(str,"%d+%d=%d\n",10,24,10+24);格式串写入str数组中。
```

- sscanf

```c
int sscanf(const char *str,const char *format,...)
    对应scanf，将原来从屏幕获取的"格式化字符串"，从参数1str中获取。
    char str[]="10+24=45";
	sscanf(str,"%d+%d=%d",&a,&b,&c);	a-->10,b-->24,c-->45
```

### 字符串查找字符、子串

- strchr

```c
char *strchr(const char *s,int c)
    在字符串中找一个字符出现的位置。返回字符在字符串中的地址
    printf("%s\n",strchr("hehehahahoho",'a')); --> "ahahoho"
```

- strrchr

```c
char *strrchr(const char *s,int c)
    自右向左，在字符串中找一个字符出现的位置。返回字符在字符串中的地址
    printf("%s\n",strrchr("hehehahahoho",'a')); --> "ahoho"
```

- strstr

```c
char *strstr(char *str,char *substr)
    参1：原串
    参2：子串
    返回值：子串在原串中的位置(地址值)
    	   如果没有：NULL
    在字符串str中，找出子串substr第一次出现的位置。返回地址
    printf("%s\n",strstr("hehehahahoho",'ho')); --> "hoho"
    printf("%s\n",strstr("hehehahahoho",'xixi')); --> NULL
```

### 字符串分割

```c
char *strtok(char *str,const char *delim)
    参1：待拆分的字符串
    参2：分割符组成的"分割串"
返回值：字符串拆分后的首地址。"拆分"：将 分割字符用 '\0' 替换
特性：
    strtok拆分字符串是直接在原串上操作，所以要求参1必须可读可写(char *str="www.baidu.com"不行！！)
    第一次拆分，参1 传 待拆分的原串。第 1+次 拆分，参1传NULL(把第一次拆分剩余的子串传递进来)
```

```c
char str[]="www.baidu.com.this is a strtok$test";
char *p=strtok(str,"$ .");		//分割串顺序任意
while(p!=NULL){
    p=strtok(NULL," .$");
    printf("p=%s\n",p);
}
```

### 字符串转整数、浮点数、长整数

```c
int atoi(const char *nptr)
atoi：字符串 转 整数
atof：字符串 转 浮点数
atol：字符串 转 长整数
【注】：使用这类函数进行转换，要求，原串必须是可转换的字符串
【错误使用】："abc123" --> 0	"12abc345" --> 12	"123xyz" --> 123    
```

## 局部和全局

### 局部变量

- 概念：定义在函数内部的变量。
- 作用域：从定义位置开始，到包裹该变量的第一个右大括号结束。

### 全局变量

- 概念：定义在函数外部的变量。
- 作用域：从定义位置开始，默认到本文件内部。其他文件如果相使用，可以通过声明方式将作用域导出。(显式声明：extern)

### static全局变量

- 定义语法：在全局变量定义之前添加static关键字。
- 作用域：被限制在本文件内部，不允许通过声明导出到其他文件。

### static局部变量

- 定义语法：在局部变量定义之前添加static关键字。
- 特性：静态局部变量只定义一次。在全局位置。通常用来做计数器
- 作用域：从定义位置开始，到包裹该变量的第一个右大括号结束。

### 全局函数(函数)

- 定义语法：函数原型 + 函数体

### static函数

- 定义语法：static + 函数原型 + 函数体
- 作用域：static函数只能在本文件内部使用。其他文件即使声明也无效。

### 生命周期

- 局部变量：从变量定义开始，函数调用完成。 --- 函数内部。
- 全局变量：程序启动开始，程序终止结束。 --- 程序执行期间。
- static局部变量：程序启动开始，程序终止结束。 --- 程序执行期间。
- static全局变量：程序启动开始，程序终止结束。 --- 程序执行期间。
- 全局函数：程序启动开始，程序终止结束。 --- 程序执行期间。
- static函数：程序启动开始，程序终止结束。 --- 程序执行期间。

## 头文件守卫

- 通常的头文件守卫的格式如下：

```c
#ifndef HEADER_NAME_H
#define HEADER_NAME_H

// 头文件内容

#endif
```

- 其中，HEADER_NAME_H是一个唯一的标识符，可以根据需要自定义。在编译过程中，首先会检查#ifndef指令，如果HEADER_NAME_H未定义，则继续执行后续的#define指令，将HEADER_NAME_H定义为一个非零值。然后编译器会继续编译头文件中的内容。如果在同一个编译单元中再次包含该头文件，由于HEADER_NAME_H已经被定义，因此#ifndef指令的条件不满足，后续的代码将被忽略。

- **通过使用头文件守卫，可以避免重复包含头文件带来的编译错误**。同时，头文件守卫也可以提高编译效率，因为编译器不需要重复编译已经包含过的头文件。

## 带参数的main函数

- 无参main函数：int main(void) == int main()

- 带参数的main函数：int main(int argc,char *argv[]) == int main(int argc,char **argv)

  参1：表示给main函数传递的参数的总个数

  参2：是一个数组！数组的每一个元素都是字符串char *

```c
int main(int argc,char *argv[])
{
    for(size_t i=0;i<argc;i++){
        printf("argv[%d]=%s\n",i,argv[i]);
    }
}
```

```c
测试1：
    命令行中，使用gcc编译生成可执行文件，如：test.exe
    test.exe abc xyz zhangsan
    -->
    argc=4
    text.exe --- argv[0]
         abc --- argv[1]
    	 xyz --- argv[2]
    zhangsan --- argv[3]
```

```c
测试2：
    在VS中。项目名称上 --》右键 --》属性 --》调试 --》命令行参数 --》将 abc xyz zhangsan 写入
    argc=4
  文件所在路径 --- argv[0]
         abc --- argv[1]
    	 xyz --- argv[2]
    zhangsan --- argv[3]
```

## 逗号表达式

逗号表达式（comma expression）是一种C语言中的表达式，它由多个表达式通过逗号连接而成。逗号表达式的值是最后一个表达式的值。

逗号表达式的语法形式为：`expr1, expr2, expr3, ... , exprn`。

逗号表达式的求值过程是从左到右依次求值每个表达式，并且返回最后一个表达式的值。逗号表达式的主要作用是在某些需要多个表达式的地方使用，例如函数调用的参数列表、for循环的控制表达式等。

下面是一个使用逗号表达式的示例：

```c
int a = 1, b = 2, c = 3;
int max = (a > b ? (a > c ? a : c) : (b > c ? b : c));
```

在上面的代码中，逗号表达式`(a > b ? (a > c ? a : c) : (b > c ? b : c))`用于计算a、b、c三个数中的最大值，并将结果赋给变量max。